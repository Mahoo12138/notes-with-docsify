+ Microsoft 宏汇编器（称为 [MASM](http://www.masm32.com/)）是一种工业软件开发工具，由一家主要的操作系统供应商维护和更新了30多年。它从未被软化或妥协为一个消费者友好的工具，并被设计为专业程序员用于操作系统级代码和高性能对象模块、可执行文件和动态链接库。

+ 访问（[asmirvine.com](http://asmirvine.com/)），了解 Visual Studio 对 MASM 支持的最新详细信息。同时，网站中还包括很多关于如何设置软件并开始使用的有用信息

### 汇编器和链接器

 汇编器（assembler）是一种工具程序，用于将汇编语言源程序转换为机器语言。链接器（linker）也是一种工具程序，它把汇编器生成的单个文件组合为一个可执行程序。还有一个相关的工具，称为调试器（debugger），使程序员可以在程序运行时，单步执行程序并检查寄存器和内存状态。

+ **汇编语言的应用**

  1. 硬件设备驱动程序：对硬件的访问直接且简单。当程序较短且文档良好时易于维护
  2. 需要直接访问硬件的嵌入式系统和电脑游戏：理想，因为可执行代码小，运行速度快

+ **C 和 C++ 语言具有一个独特的特性**，能够在高级结构和底层细节之间进行平衡。直接访问硬件是可能的，但是完全不可移植。大多数 C 和 C++ 编译器都允许在其代码中嵌入汇编语句，以提供对硬件细节的访问。

+ #### MASM 能创建哪些类型的程序？

  32 位保护模式（32-Bit Protected Mode）：32 位保护模式程序运行于所有的 32 位和 64 位版本的 Microsoft Windows 系统。它们通常比实模式程序更容易编写和理解。从现在开始，将其简称为 32 位模式。

  64 位模式（64-Bit Mode）：64 位程序运行于所有的 64 位版本 Microsoft Windows 系统。

  16 位实地址模式（16-Bit Real-Address Mode）：16 位程序运行于 32 位版本 Windows 和嵌入式系统。 64 位 Windows 不支持这类程序。

+ **汇编语言不是可移植的**，因为它是为特定处理器系列设计的。目前广泛使用的有多种不同的汇编语言，每一种都基于一个处理器系列。

  对于一些广为人知的处理器系列如 Motorola 68x00、x86、SUN Sparc、Vax 和 IBM-370，汇编语言指令会直接与该计算机体系结构相匹配，或者在执行时用一种被称为微代码解释器（microcode interpreter）的处理器内置程序来进行转换。
  
+ 计算机通常可以执行用其原生机器语言编写的程序。这种语言中的每一条指令都简单到可以用相对少量的电子电路来执行。为了简便，称这种语言为 L0。

  由于 L0 极其详细，并且只由数字组成，因此，程序员用其编写程序就非常困难。如果能够构造一种较易使用的新语言 L1，那么就可以用 L1 编写程序。有两种实现方法：

  - 解释（Interpretation）：运行 L1 程序时，它的每一条指令都由一个用 L0 语言编写的程序进行译码和执行。L1 程序可以立即开始运行，但是在执行之前，必须对每条指令进行译码。
  - 翻译（Translation）：由一个专门设计的 L0 程序将整个 L1 程序转换为 L0 程序。然后，得到的 L0 程序就可以直接在计算机硬件上执行。


### 存储和度量

+ 大的度量单位对内存和磁盘空间而言，还可以使用大的度量单位：

  - 1 千字节（kilobyte）等于 2^10^，或 1024 个字节。
  - 1 兆字节（megabyte）（1MB）等于 2^20^，或 1 048 576 字节。
  - 1 吉字节（gigabyte）（1GB）等于 2^30^ 即 10243，或 1 073 741 824 字节。
  - 1 太字节（terabyte）（1TB）等于 2^40^，即 10244，或 1 099 511 627 776 字节。
  - 1 拍字节（petabyte）等于 2^50^，或 1 125 899 906 842 624 字节。
  - 1 艾字节（exabyte）等于 2^60^，或 1 152 921 504 606 846 976 字节。
  - 1 泽字节（zettabyte）等于 2^70^ 个字节。
  - 1 尧字节（yottabyte）等于 2^80^ 个字节。
  
+ 一个字节 8 位。其他的存储单位还有字（word）（2 个字节），双字（doubleword，4 个字节）和四字（quadword，8 个字节）

  ![存储单元所包含的位数](https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn/hexo-images/4-1Z4251F306461.gif)

+ 小段顺序

  x86 处理器在内存中按小端（little-endian）顺序（低到高）存放和检索数据。最低有效字节存放在分配给该数据的第一个内存地址中，剩余字节存放在随后的连续内存位置中。考虑一个双字 12345678h。如果将其存放在偏移量为 0000 的位置，则 78h 存放在第一个字节，56h 存放在第二个字节，余下的字节存放地址偏移量为 0002 和 0003，如下图所示。

  ![12345678h小端表示](https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn/note-images/4-1Z42913400G13.gif)

  
  其他有些计算机系统采用的是大端顺序（高到低）。 下图展示了 12345678h 从偏移量 0000 开始的大端顺序存放。

  ![12345678h的大端表示](https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn/note-images/4-1Z429134050246.gif)

### 进制转换

1. **有符号二进制数到十进制的转换**

   - 如果最高位是 1，则该数是补码。再次对其求补，得到其正数值。然后把这个数值看作是一个无符号二进制整数，并求它的十进制数值。
   - 如果最高位是 0，就将其视为无符号二进制整数，并转换为十进制数。
   
   
      例如，有符号二进制数 1111 0000 的最高有效位是 1，这意味着它是一个负数，首先要求它的补码，然后再将结果转换为十进制。过程如下所示：
   
   | 初始值                         | 11110000     |
   | ------------------------------ | ------------ |
   | 第一步：按位取反               | 00001111     |
   | 第二步：将上一步得到的结果加 1 | 00001111 + 1 |
   | 第三步：生成补码               | 00010000     |
   | 第四步：转换为十进制           | 16           |
   
      由于初始值（1111 0000）是负数，因此其十进制数值为 -16。
   
   2. **有符号十进制数到二进制的转换**

      + 把十进制整数的绝对值转换为二进制数。

      + 如果初始十进制数是负数，则在第 1 步的基础上，求该二进制数的补码。

      比如，十进制数 -43 转换为二进制的过程为：

         1) 无符号数 43 的二进制表示为 0010 1011。

         2) 由于初始数值是负数，因此，求出 0010 1011 的补码 1101 0101 这就是十进制数 -43 的二进制表示。

3. **有符号十进制数到十六进制的转换**
   + 把十进制整数的绝对值转换为十六进制数。
   + 如果初始十进制数是负数，则在第 1 步的基础上，求该十六进制数的补码。

4. **有符号十六进制数到十进制的转换**

   + 如果十六进制整数是负数，求其补码，否则保持该数不变。

   + 把第 1 步得到的整数转换为十进制。如果初始值是负数，则在该十进制整数的前面加负号。


通过检查十六进制数的最高有效（最高）位，就可以知道该数是正数还是负数。**如果最高位 ≥ 8，该数是负数；如果最高位 ≤ 7，该数是正数**。比如，十六进制数 8A20 是负数，而 7FD9 是正数。

