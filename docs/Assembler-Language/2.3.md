## 汇编-链接-执行周期

![汇编-链接-执行周期](https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn/note-images/4-1Z42QJ55Y01.gif)

- 步骤1：编程者用文本编辑器 (text editor) 创建一个 ASCII 文本文件，称之为**源文件**。
- 步骤2：汇编器读取源文件，并**生成目标文件**，即对程序的机器语言翻译。或者，它也会生成列表文件。只要出现任何错误，编程者就必须返回步骤 1，修改程序。
- 步骤3：链接器**读取并检查目标文件**，以便发现该程序是否包含了任何对链接库中过程的调用。链接器从链接库中复制任何被请求的过程，将它们与目标文件组合，以生成可执行文件。
- 步骤4：操作系统加载程序**将可执行文件读入内存**，并使 CPU 分支到该程序起始地址，然后程序开始执行。

## 列表文件

列表文件 (listing file) 包括了程序源文件的副本，再加上行号、每条指令的数字地址、每条指令的机器代码字节（十六进制）以及符号表。符号表中包含了程序中所有标识符的名称、段和相关信息。

下面的代码展示了 AddTwo 程序的部分列表文件，现在进一步查看这个文件。1~6 行没有可执行代码，因此它们原封不动地从源文件中直接复制过来。第 8 行表示代码段开始的地址为 0000 0000（在 32 位程序中，地址显示为 8 个十六进制数字）。这个地址是**相对于程序内存占用起点而言**的，但是，当程序加载到内存中时，这个地址就会**转换为绝对内存地址**。此时，该程序就会从这个地址开始，比如 0004 0000h。

```assembly
; AddTwo.asm - adds two 32-bit integers.

.386
.model flat,stdcall
.stack 4096
ExitProcess PROTO,dwExitCode:DWORD

00000000                            .code
00000000                            main PROC
00000000 B8 00000005                    mov eax, 5
00000005 83 C0 06                       add eax, 6

										invoke ExitProcess,0
00000008 6A 00                          push        +000000000h
0000000A E8 00000000 E                  call        ExitProcess
0000000F                            main ENDP
END main
```

第 9 行和第 10 行也显示了相同的开始地址 0000 0000，原因是：第一条可执行语句是 MOV 指令，它在第 10 行。请注意第 10 行中，在地址和源代码之间出现了几个十六进制字节，这些字节（B8 0000 0005）代表的是机器代码指令（B8 ），而该指令分配给 EAX 的就是 32 位常数值（0000 0005）：

```assembly
00000000 B8 00000005 mov eax, 5
```

**数值 B8 也被称为操作代码**（或简称为操作码），因为它表示了**特定的机器指令**，将一个 32 位整数送入 eax 寄存器。

第 11 行也是一条可执行指令，起始偏移量为 0000 0005。这个偏移量是指从程序起始地址开始 5 个字节的距离。

第 13 行有 invoke 伪指令。注意第 14 行和 15 行是如何插入到这段代码中的，插入代码的原因是，**INVOKE 伪指令使得汇编器生成 PUSH 和 CALL 语句**，它们就显示在第 14 行和 15 行。

代码中展示的示例列表文件说明了机器指令是怎样以整数值序列的形式加载到内存的，在这里用十六进制表示：B8、0000 0005、83、C0、06、6A、00、EB、0000 0000。**每个数中包含的数字个数暗示了位的个数**：<u>2 个数字就是 8 位，4 个数字就是 16 位，8 个数字就是 32 位</u>，以此类推。所以，本例机器指令长正好是 15 个字节（2 个 4 字节值和 7 个 1 字节值）。

当程序员想要确认汇编器是否按照自己的程序生成了正确的机器代码字节时，列表文件就是最好的资源。**如果是刚开始学习机器代码指令是如何生成的，列表文件也是一个很好的教学工具。**

若想告诉 Visual Studio 生成列表文件，则在打开项目时按下述步骤操作：在 *项目* 菜单中选择 *XXX 属性页*，选择 *Microsoft Macro Assembler* 然后选择 *Listing File*。在对话框中，设置 *Generate Preprocessed Source Listing* 为 **是 (/EP)**，设置 *List All Available Information* 为 **是 (/Sa)**，Assembled Code Listing File 为**$(ProjectName).lst**，就能在项目的目录找到了。

## 数据类型

汇编器识别一组基本的内部数据类型（intrinsic data type），按照数据大小（字节、字、双字等等）、是否有符号、是整数还是实数来描述其类型。这些类型有相当程度的重叠，例如，DWORD 类型（32 位，无符号整数）就可以和 SDWORD 类型（32 位，有符号整数）相互交换。

下表给出了全部内部数据类型的列表，有些表项中的 IEEE 符号指的是 IEEE 计算机学会出版的标准实数格式。

| 类型   | 用法                                   |
| ------ | -------------------------------------- |
| BYTE   | 8 位无符号整数，B 代表字节             |
| SBYTE  | 8 位有符号整数，S 代表有符号           |
| WORD   | 16 位无符号整数                        |
| SWORD  | 16 位有符号整数                        |
| DWORD  | 32 位无符号整数，D 代表双（字）        |
| SDWORD | 32 位有符号整数，SD 代表有符号双（字） |
| FWORD  | 48 位整数（保护模式中的远指针）        |
| QWORD  | 64 位整数，Q 代表四（字）              |
| TBYTE  | 80 位（10 字节）整数，T 代表 10 字节   |
| REAL4  | 32 位（4 字节）IEEE 短实数             |
| REAL8  | 64 位（8 字节）IEEE 长实数             |
| REAL10 | 80 位（10 字节）IEEE 扩展实数          |

### 数据定义语句

数据定义语句（data definition statement）在内存中为变量留岀存储空间，并赋予一个可选的名字。数据定义语句根据内部数据类型（上表）定义变量。

数据定义语法如下所示：

```assembly
[name] directive initializer [,initializer]...
```

下面是数据定义语句的一个例子：

```assembly
count DWORD 12345
```

数据定义中至少要有一个初始值，即使该值为 0。其他初始值，如果有的话，用逗号分隔。对整数数据类型而言，初始值（initializer）是整数常量或是与变量类型，如 BYTE 或 WORD 相匹配的整数表达式。

如果不希望对变量进行初始化（随机分配数值），可以用符号 `?` 作为初始值。所有初始值，不论其格式，都由汇编器转换为二进制数据。初始值 0011 0010b、32h 和 50d 都具有相同的二进制数值。

并不是所有的数据定义都要用标号。比如，在 list 后面继续添加字节数组，就可以在下一行定义它们：

```assembly
list BYTE 10,20,30,40
BYTE 50,60,70,80
BYTE 81,82,83,84
```

在单个数据定义中，其初始值可以使用不同的基数。字符和字符串常量也可以自由组合。在下面的例子中，list1 和 list2 有相同的内容：

```assembly
list1 BYTE 10, 32, 41h, 00100010b
list2 BYTE 0Ah, 20h, 'A', 22h
```

### 定义字符串

定义一个字符串，要用单引号或双引号将其括起来。

最常见的字符串类型是用**一个空字节（值为0）作为结束标记**，称为以空字节结束的字符串，很多编程语言中都使用这种类型的字符串：

```assembly
greeting1 BYTE "Good afternoon",0
greeting2 BYTE 'Good night',0
```

**每个字符占一个字节的存储空间**。对于字节数值必须用逗号分隔的规则而言，字符串是一个例外。如果没有这种例外，greeting1 就会被定义为：

```assembly
greeting1 BYTE 'G', 'o', 'o', 'd'....etc.
```

这就显得很冗长。一个字符串可以分为多行，**并且不用为每一行都添加标号**：

```assembly
greeting1 BYTE "Welcome to the Encryption Demo program "
BYTE "created by Kip Irvine.",0dh, 0ah
BYTE "If you wish to modify this program, please "
BYTE "send me a copy.",0dh,0ah,0
```

十六进制代码 `0Dh` 和 `0Ah` 也被称为 **CR/LF （回车换行符）**或行结束字符。在编写标准输出时，它们将光标移动到当前行的下一行的左侧。

**行连续字符（\）把两个源代码行连接成一条语句**，它必须是一行的**最后一个字符**。下面的语句是等价的：

```assembly
greeting1 BYTE "Welcome to the Encryption Demo program "
greeting1 \
BYTE "Welcome to the Encryption Demo program "
```

### DUP 操作符

DUP 操作符使用一个整数表达式作为计数器，为多个数据项分配存储空间。在为字符串或数组分配存储空间时，这个操作符非常有用，它可以使用初始化或非初始化数据：

```assembly
BYTE 20 DUP (0)      	;20 个字节，值都为 0
BYTE 20 DUP (?)      	;20 个字节，非初始化
BYTE  4 DUP ("STACK")   ;20 个字节："STACKSTACKSTACKSTACK"
```

### 定义压缩 BCD（TBYTE）数据

Intel 把一个压缩的二进制编码的十进制（BCD, Binary Coded Decimal）整数存放在一个 10 字节的包中。每个字节（除了最高字节之外）包含两个十进制数字。在低 9 个存储字节中，每半个字节都存放了一个十进制数字。最高字节中，**最高位表示该数的符号位。如果最高字节为 80h，该数就是负数；如果最高字节为 00h，该数就是正数**。整数的范围是 -999 999 999 999 999 999 到 +999 999 999 999 999 999。

示例下表列出了正、负十进制数 1234 的十六进制存储字节，排列顺序从最低有效字节到最高有效字节：

| 十进制数值 | 存储字节                      |
| ---------- | ----------------------------- |
| +1234      | 34 12 00 00 00 00 00 00 00 00 |
| -1234      | 34 12 00 00 00 00 00 00 00 80 |


MASM 使用 `TBYTE` 伪指令来定义压缩 BCD 变量。**常数初始值必须是十六进制的**，因为，汇编器不会自动将十进制初始值转换为 BCD 码。下面的两个例子展示了十进制数 -1234 有效和无效的表达方式：

```
intVal TBYTE 800000000000001234h ;有效
intVal TBYTE -1234               ;无效
```

第二个例子无效的原因是 MASM 将常数编码为二进制整数，而不是压缩 BCD 整数。

如果想要把一个实数编码为压缩 BCD 码，可以先用 `FLD` 指令将该实数加载到浮点寄存器堆栈，再用 `FBSTP` 指令将其转换为压缩 BCD 码，该指令会把数值舍入到最接近的整数：

```assembly
.data
posVal REAL8 1.5
bcdVal TBYTE ?
.code
fid posVal 		;加载到浮点堆栈
fbstp bcdVal 	;向上舍入到 2，压缩 BCD 码值
```

如果 posVal 等于 1.5，结果 BCD 值就是 2。

### 声明未初始化数据

 `.DATA ?` 伪指令声明未初始化数据。当定义大量未初始化数据时，`.DATA ?` 伪指令**减少了编译程序的大小**。例如，下述代码是有效声明：

```assembly
.data
smallArray DWORD 10 DUP (0) ;40 个字节
.data?
bigArray DWORD 5000 DUP (?) ;20 000 个字节，未初始化
```

而另一方面，下述代码生成的编译程序将会多岀 20 000 个字节：

```assembly
.data
smallArray DWORD 10 DUP (0)  ; 40 个字节
bigArray DWORD 5000 DUP (?)  ; 20 000 个字节
```

#### 代码与数据混合

汇编器允许在程序中进行代码和数据的来回切换。比如，想要声明一个**变量**，使其**只能在程序的局部区域中使用**。下述示例在两个代码语句之间插入了一个名为 temp 的变量：

```assembly
.code
mov eax,ebx
.data
temp DWORD ?
.code
mov temp,eax
```

尽管 temp 声明的出现打断了可执行指令流，**MASM 还是会把 temp 放在数据段中**，并与保持编译的代码段分隔开。然而同时，**混用 .code 和 .data 伪指令会使得程序变得难以阅读。**

## 向 AddTwo 程序添加一个变量

```assembly
; AddTwo.asm - adds two 32-bit integers.
.386
.model flat,stdcall
.stack 4096
ExitProcess PROTO,dwExitCode:DWORD

.data
sum DWORD 0

.code
main PROC
    mov eax, 5
    add eax, 6
    mov sum, eax
    INVOKE ExitProcess,0
main ENDP
END main
```

打开一个 **监视** 窗口，打开过程如下：在 *调试* 菜单中选择 *窗口*（在调试会话中），选择 *监视*，并在四个可用选项中选择一个。然后，用鼠标高亮显示 sum 变量，将其拖拉到监视窗口中。

![](https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn/note-images/image-20201015164845690.png)