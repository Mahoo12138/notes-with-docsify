## 算法时间度量指标

一个算法所实施的**操作数量或步骤数**可作为独立于具体程序/机器的**度量指标**。

那么则需要一种通用的基本操作来作为运行步骤的计量单位，**赋值语句**就是一个合适的选择。一条赋值语句同时包含了（表达式）计算和（变量） 存储两个基本资源。

仔细观察程序设计语言特性，除了与计算资源无关的定义语句外，主要就是三种控制流语句和赋值语句，而控制流仅仅起了组织语句的作用，并不实施处理。

## 赋值语句执行次数

分析 SumOfN 的赋值语句执行次数，赋值语句数量可记为 `T(n)=1+n`：

```python
def sumOfn(n):
    sum = 0
    for i in range(1,n + 1):
        sum = sum + i
    return sum
```

## 问题规模影响算法执行时间

在分析赋值语句数量时，引出了一个概念：**问题规模**——影响算法执行时间的主要因素。在前 n 个整数累计求和的算法中，需要累计的整数个数是合适作为问题规模的指标，前 100,000 个整数求和对比前 1,000 个整数求和 ，算是同一问题的更大规模。

那么，算法分析的目标是要找出问题规模会怎么影响一个算法的执行时间。

## 数量级函数

基本操作数量函数`T(n)`的精确值并不是特别重要，重要的是`T(n)`中起决定性因素的主导部分，用动态的眼光看，就是当问题规模增大的时候， `T(n)`中的一些部分会盖过其它部分的贡献

**数量级函数**描述了`T(n)`中随着 n 增加而增加速度最快的**主导部分**，这样的描述称作称作**“大O”表示法**，记作`O(f(n))`，其中 `f(n)` 表示 `T(n) `中的主导部分。

### 确定运行时间数量级大O的方法

例如，*T(n) = 1 + n* ，当 n 增大时，常数 1 在最终结果中显得越来越**无足轻重**，所以可以去掉 1，保留 n 作为主要部分，运行时间数量级就是**O(n)**。

再例如，*T(n) = 5n^2^ + 27n + 1005*，当 n 很小时，常数 1005 其决定性作用，但当 n 越来越大，n^2^ 项就越来越重要，其它两项对结果的影响则越来越小；同样，n^2^ 项中的系数 5，对于 n^2^ 的增长速度来说，也影响不大，所以可以在数量级中**去掉 27n + 1005**，以及系数 5 的部分，确定为**O(n2)**。

## 影响算法运行时间的其它因素

有时决定运行时间的不仅是问题规模，某些具体数据也会影响算法运行时间。

大致可分为最好、最差和平均情况，平均状况体现了算法的主流性能，对算法的分析要看主流，而不被某几种特定的运行状况所迷惑。

## 常见的大O数量级函数

通常当n较小时，难以确定其数量级，而当 n 增长到较大时，容易看出其主要变化量级：

| f(n)    | 名称     |
| ------- | -------- |
| 1       | 参数     |
| log(n)  | 对数     |
| n       | 线性     |
| nlog(n) | 对数线性 |
| n^2^    | 平方     |
| n^3^    | 立方     |
| 2^n^    | 指数     |

<img src="D:\Mahoo12138\Desktop\image-20201104164414064.png" style="zoom:67%;" />

## 从代码分析确定执行时间数量级函数

例如，如下代码（忽略 n 的声明）：

```python
a = 5
b = 6
c = 10
# --------------- #
for i in range(n):
    for j in range(n):
        x = i * i
        y = j * j
        z = i * j
# --------------- #
for k in range(n):
    w = a * k + 45
    v = b * b
# --------------- #
d = 33
```

代码可分为四段，总共是 T(n) = 3 + 2n^2^ + 2n + 1 = **3n^2^ + 2n + 4**，然后仅保留最高阶项 n^2^ ，去掉所有系数，则数量级为O( n^2^ )。

## 其它算法复杂度表示法