写出一个可以工作的程序并不够。如果这个程序在巨大的数据集上运行，那么运行时间就变成了重要的问题。

### 数学知识复习

1. 指数基本公式
   $$
   X^A+X^B=X^{(A+B)}\\
   {X^A\over X^B}=X^{(A−B)}\\
   (X^A)^B=X^{AB}\\
   X^N+X^N=X^{(N+1)}≠X^{2N}
   $$
   
2. 对数基本公式

   在计算机科学中，除非有特别的声明，所有的对数都是以 2 为底的。
   $$
   \log_AB={\log_CB\over\log_CA}
   $$

   $$
   \log AB=\log A + \log B
   $$

   $$
   \log (A^B)=B\log A
   $$

   $$
   \log X > X\ (X>0)
   $$

3. 级数基本公式

   几何级数：
   $$
   \sum_{i=0}^{N}A^i={A^{N+1}-1\over{A-1}}
   $$
   算数级数：
   $$
   \sum_{i=0}^{N}i={N(N+1)\over 2}\approx{N^2\over 2}
   $$

4. 模运算公式

   如果 N 整除 A-B，那么称 A 与 B 模 N 同余，记作$A\equiv B({\rm mod}\ N)$

5. 证明方法

   + **归纳法**
     1. 证明基准情形：确定定理对于某个（些）小的值的正确性；
     2. 归纳假设：假设对某个有限数 K 都是成立的，然后据此假设证明对下一个值（通常为 K+1）也成立；
   + **反证法**：通过假设定理不成立，然后证明该假设导致某个已知的性质不成立，从而说明说假设是错误的。

### 递归简论

当一个函数它用自己来定义时就是**递归**，其有四个基本法则：

+ 基准情形：必须有某些基准的情形，它们不用递归就能求解；
+ 不断推进：对于那些需要递归求解的情形，递归调用必须能够朝着产生基准情形的方向推进；
+ 设计法则：假设所有的递归调用都能运行；
+ 合成效益法则：在求解一个问题的同一实例时，*切勿在不同的递归调用中做重复性的工作*；