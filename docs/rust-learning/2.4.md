## 流程控制

### 分支控制

+ **`if` 语句块是表达式**，可使用 `if` 表达式的返回值来给进行变量赋值；
+ 用 `if` 来赋值时，要保证每个分支返回的类型一样（不完全准确）；

### 循环控制

Rust 语言中有三种循环方式：`for`、`while` 和 `loop`：

#### for 循环

```rust
for 元素 in 集合 {
  // 使用元素干一些你懂我不懂的事情
}
```

使用 `for` 时我们往往使用集合的引用形式，如果不使用引用的话，**所有权会被转移（move）到 `for` 语句块中**，后面就无法再使用这个集合了；

> 对于实现了 `copy` 特征的数组(例如 [i32; 10] )而言， `for item in arr` 并不会把 `arr` 的所有权转移，而是直接对其进行了拷贝；

如果想在循环中，**修改该元素**，可以使用 `mut` 关键字：

```rust
for item in &mut collection {
  // ...
}
```

如果想在循环中**获取元素的索引**：

```rust
let a = [4, 3, 2, 1];
// `.iter()` 方法把 `a` 数组变成一个迭代器
for (i, v) in a.iter().enumerate() {
    println!("第{}个元素是{}", i + 1, v);
}
```

#### 两种循环方式优劣对比

```rust
// 第一种
let collection = [1, 2, 3, 4, 5];
for i in 0..collection.len() {
  let item = collection[i];
  // ...
}

// 第二种
for item in collection {

}
```

第一种方式是循环索引，然后通过索引下标去访问集合，第二种方式是直接循环集合中的元素，优劣如下：

- **性能**：第一种使用方式中 `collection[index]` 的索引访问，会因为边界检查(Bounds Checking)导致运行时的性能损耗 —— Rust 会检查并确认 `index` 是否落在集合内，但是第二种直接迭代的方式就不会触发这种检查，因为编译器会在编译时就完成分析并证明这种访问是合法的
- **安全**：第一种方式里对 `collection` 的索引访问是非连续的，存在一定可能性在两次访问之间，`collection` 发生了变化，导致脏数据产生。而第二种直接迭代的方式是连续访问，因此不存在这种风险（这里是因为所有权吗？是的话可能要强调一下）

#### 循环控制

+ 使用 `continue` 可以跳过当前当次的循环；

+ 使用 `break` 可以直接跳出当前整个循环；

当有多层循环时，你可以使用 `continue` 或 `break` 来控制外层的循环。要实现这一点，外部的循环必须拥有一个标签 `'label`, 然后在 `break` 或 `continue` 时指定该标签；

### loop 

`loop` 就是一个简单的无限循环，你可以在内部实现逻辑通过 `break` 关键字来控制循环何时结束。

- **break 可以单独使用，也可以带一个返回值**，有些类似 `return；`
- **loop 是一个表达式**，因此可以返回一个值；