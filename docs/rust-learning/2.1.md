##  手动设定变量的可变性

大多数语言中，要么只支持声明可变的变量，要么只支持声明不可变的变量( 例如函数式语言 )，前者为编程提供了灵活性，后者为编程提供了安全性，而 Rust 选择了两者我都要，既要灵活性又要安全性。

在 rust 中，变量赋值称作**变量绑定**，这是因为如此更贴近**所有权**这个概念；

+ 变量在默认情况下是**不可变的**；
+ 可以通过 `mut` 关键字让变量变为**可变的**；

选择可变还是不可变，更多的还是取决于使用场景；

+ 例如不可变可以带来安全性，但是丧失了灵活性和性能（如果你要改变，就要重新创建一个新的变量，这里涉及到内存对象的再分配）。而可变变量最大的好处就是使用上的灵活性和性能上的提升。
+ 例如，在使用大型数据结构或者*热点代码路径*（被大量频繁调用）的情形下，在同一内存位置更新实例可能比复制并返回新分配的实例要更快。使用较小的数据结构时，通常创建新的实例并以更具函数式的风格来编写程序，可能会更容易理解，所以值得以较低的性能开销来确保代码清晰。

**可以用下划线作为变量名的开头，提示Rust 不要警告未使用的变量**；

常量使用 `const` 关键字声明，并且值的类型**必须**标注，不允许使用 `mut`；

Rust 允许声明相同的变量名，在后面声明的变量会遮蔽掉前面声明的：

+ 这和 `mut` 变量的使用是不同的，第二个 `let` 生成了完全不同的新变量，只是恰好拥有同样的名称，涉及一次内存对象的再分配 ，
+ 而 `mut` 声明的变量，可以修改同一个内存地址上的值，并不会发生内存对象的再分配，性能要更好。

### 作业

```rust
fn main() {
    let x = define_x();
    println!("{}, world", x);
}

fn define_x() -> String {
    let x = "hello".to_string();
    x
}
// 分割线 //
fn main() {
    let x = define_x();
    println!("{:?}, world", x);
}

fn define_x() -> &'static str {
    let x = "hello";
    x
}
```

```rust
#[allow(unused_variables)]
fn main() {
    let x = 1;
}
```

## 基本类型

### 整数类型

整型定义的形式统一为：`有无符号 + 类型大小(位数)`，Rust 整型默认使用 `i32`；

`isize` 和 `usize` 的主要应用场景是用作集合的索引；

> **整型溢出**
>
> debug 模式编译时，Rust 会检查整型溢出，若存在这些问题，则使程序在编译时 *panic*;
>
> release 模式，Rust **不**检测溢出。相反，当检测到整型溢出时，Rust 会按照补码循环溢出（*two’s complement wrapping*）的规则处理（`u8` 的情况下，256 -> 0，257 -> 1）；

要显式处理可能的溢出，可以使用标准库针对原始数字类型提供的这些方法：

- 使用 `wrapping_*` 方法在所有模式下都按照补码循环溢出规则处理，例如 `wrapping_add`
- 如果使用 `checked_*` 方法时发生溢出，则返回 `None` 值
- 使用 `overflowing_*` 方法返回该值和一个指示是否存在溢出的布尔值
- 使用 `saturating_*` 方法使值达到最小值或最大值

### 浮点类型

在 Rust 中浮点类型数字也有两种基本类型： `f32` 和 `f64`，分别为 32 位和 64 位大小。

默认浮点类型是 `f64`，在现代的 CPU 中它的速度与 `f32` 几乎相同，但精度更高；

> 浮点数陷阱
>
> + **浮点数往往是你想要数字的近似表达**；
> + **浮点数在某些特性上是反直觉的**；

对于数学上未定义的结果，例如对负数取平方根 `-42.1.sqrt()` ，会产生一个特殊的结果：Rust 的浮点数类型使用 `NaN` (not a number)来处理这些情况。

+ 可以使用 `is_nan()` 等方法，可以用来判断一个数值是否是 `NaN`；



### 序列（Range）

Rust 提供了一个非常简洁的方式，用来生成连续的数值，例如 `1..5`，生成从 1 到 4 的连续数字，不包含 5 ；`1..=5`，生成从 1 到 5 的连续数字，包含 5；

序列只允许用于数字或字符类型，原因是：**它们可以连续**，同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型。

## 字符、布尔、单元类型

### 字符

由于 `Unicode` 都是 4 个字节编码，因此字符类型也是占用 4 个字节；

```rust
fn main() {
    let x = '中';
    println!("字符'中'占用了{}字节的内存大小",std::mem::size_of_val(&x));
}
```

### 布尔

略

### 单元类型

单元类型就是 `()` ，`main` 函数就返回这个单元类型 `()`，你不能说 `main` 函数无返回值，因为没有返回值的函数在 Rust 中是有单独的定义的：`发散函数( diverge function )`，顾名思义，无法收敛的函数。

例如常见的 `println!()` 的返回值也是单元类型 `()`。单元类型，不占内存空间，因为他是个空的元组；

## 语句和表达式

语句会执行一些操作但是不会返回一个值，而表达式会在求值后返回一个值：

```rust
#![allow(unused)]
fn main() {
    fn add_with_extra(x: i32, y: i32) -> i32 {
        let x = x + 1; // 语句
        let y = y + 5; // 语句
        x + y // 表达式
    }
}
```

能返回值，它就是表达式：

+ 调用一个函数是表达式，因为会返回一个值，不返回则为 () 单元类型；
+ 调用宏也是表达式；
+ 用花括号包裹最终返回一个值的语句块也是表达式；

**表达式不能包含分号**。一旦在表达式后加上分号，它就会变成一条语句；

## 函数

- 函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可；
- 函数的返回值就是函数体最后一条表达式的返回值，当然也可以使用 `return` 提前返回；
- 当用 `!` 作函数返回类型的时候，表示该函数永不返回( diverge function )，特别的，这种语法往往用做会导致程序崩溃的函数；

```rust
fn dead_end() -> ! {
  panic!("你已经到了穷途末路，崩溃吧！");
}
```

