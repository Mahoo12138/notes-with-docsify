## 所有权

- **垃圾回收机制(GC)**，在程序运行时不断寻找不再使用的内存，典型代表：Java、Go
- **手动管理内存的分配和释放**, 在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++
- **通过所有权来管理内存**，编译器在编译时会根据一系列规则进行检查，即 Rust

### 栈(Stack)与堆(Heap)

+ 栈按照顺序存储值并以相反顺序取出值，这也被称作**后进先出**；栈中的所有数据都必须占用已知且固定大小的内存空间；
+ 对于大小未知或者可能变化的数据，需要将它存储在堆上；且需要请求一定大小的内存空间，并返回一个表示该位置地址的**指针**；
+ 接着，该指针会被推入**栈**中，因为指针的大小是已知且固定的，在后续使用过程中，你将通过栈中的**指针**，来获取数据在堆上的实际内存位置，进而访问该数据；
+ 入栈比在堆上分配内存要快；访问堆上的数据比访问栈上的数据慢；

+ 当你的代码调用一个函数时，传递给函数的参数（包括可能指向堆上数据的指针和函数的局部变量）依次被压入栈中，当函数调用结束时，这些值将被从栈中按照相反的顺序依次移除。

## 所有权原则

1. Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
2. 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
3. 当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)

> 字符串字面值 `let s ="hello"`，`s` 是被硬编码进程序里的字符串值（类型为 `&str` ）：
>
> - **字符串字面值是不可变的**，因为被硬编码到程序代码中
> - 并非所有字符串的值都能在编写代码时得知
>
> 动态字符串类型: `String`，该类型被分配到堆上，因此可以动态伸缩，也就能存储在编译时大小未知的文本

### 转移所有权

```rust
let x = 5;
let y = x;

let s1 = String::from("hello");
let s2 = s1;
```

基本类型（存储在栈上），Rust 会自动拷贝进行赋值，但是 `String` 不是基本类型，而且是存储在堆上的，因此不能自动拷贝。

`String` 类型是一个复杂类型，由**存储在栈中的堆指针**、**字符串长度**、**字符串容量**共同组成；

+ 深拷贝，即拷贝所有数据，那么无论是 `String` 本身还是底层的堆上数据，都会被全部拷贝；
+ 浅拷贝，只拷贝 `String` 本身，因为在 64 位机器上就拷贝了 `8字节的指针`、`8字节的长度`、`8字节的容量`，总计 24 字节；

如果是浅拷贝：根据原则**一个值只允许有一个所有者**，而现在这个值（堆上的真实字符串数据）则有了两个所有者：`s1` 和 `s2`。

当 `s1` 和 `s2` 离开作用域，它们都会尝试释放相同的内存。这是一个叫做 **二次释放（double free）** 的错误；

所以在 Rust 中，**当 `s1` 赋予 `s2` 后，Rust 认为 `s1` 不再有效，因此也无需在 `s1` 离开作用域后 `drop` 任何东西，这就是把所有权从 `s1` 转移给了 `s2`，`s1` 在被赋予 `s2` 后就马上失效了**。

Rust 禁止使用无效的引用，同时使第一个变量 `s1` 无效了，因此这个操作被称为 **移动(move)**，而不是浅拷贝；

### 克隆（深拷贝）

**Rust 永远也不会自动创建数据的 “深拷贝”**，需要深拷贝，可以使用一个叫做 `clone` 的方法；

```rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
```

### 拷贝（浅拷贝）

浅拷贝只发生在栈上，存储在栈上的变量调用 `clone` 并不会与通常的浅拷贝有明显区别；

Rust 有一个叫做 `Copy` 的特征，**任何基本类型的组合可以 `Copy` ，不需要分配内存或某种形式资源的类型是可以 `Copy` 的**；

### 函数传值与返回

```rust
fn main() {
    let s = String::from("hello");  // s 进入作用域

    takes_ownership(s);             // s 的值移动到函数里 ...
                                    // ... 所以到这里不再有效

    let x = 5;                      // x 进入作用域

    makes_copy(x);                  // x 应该移动函数里，
                                    // 但 i32 是 Copy 的，所以在后面可继续使用 x
} // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
  // 所以不会有特殊操作

fn takes_ownership(some_string: String) { // some_string 进入作用域
    println!("{}", some_string);
} // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放

fn makes_copy(some_integer: i32) { // some_integer 进入作用域
    println!("{}", some_integer);
} // 这里，some_integer 移出作用域。不会有特殊操作
```

当所有权转移时，可变性也可以随之改变：

```rust
let s = String::from("hello, ");
let mut s1 = s;
```

当解构一个变量时，可以同时使用 `move` 和引用模式绑定的方式。当这么做时，部分 `move` 就会发生：变量中一部分的所有权被转移给其它变量，而另一部分我们获取了它的引用：

```rust

fn main() {
    #[derive(Debug)]
    struct Person {
        name: String,
        age: Box<u8>,
    }

    let person = Person {
        name: String::from("Alice"),
        age: Box::new(20),
    };

    // 通过这种解构式模式匹配，person.name 的所有权被转移给新的变量 `name`
    // 但是，这里 `age` 变量确是对 person.age 的引用, 这里 ref 的使用相当于: let age = &person.age 
    let Person { name, ref age } = person;

    println!("The person's age is {}", age);

    println!("The person's name is {}", name);

    // Error! 原因是 person 的一部分已经被转移了所有权，因此我们无法再使用它
    //println!("The person struct is {:?}", person);

    // 虽然 `person` 作为一个整体无法再被使用，但是 `person.age` 依然可以使用
    println!("The person's age from person struct is {}", person.age);
}
```



